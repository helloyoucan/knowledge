## 1  声明

- `const` 声明常量，需声明时赋值（仅在块级作用域内有效）
- `let` 声明变量，可声明时或使用时赋值（仅在块级作用域内有效）
- `var` 声明变量，具有变量提升（可**声明前**使用）
- `function` 声明函数，具有函数提升（可**声明赋值前**使用）

**6个**用于声明的关键字

`var、const、let、function、class、import`

作用域：

- 全局作用域
- 函数作用域：function(){}
- 块级作用域：{}

`const`和`let`注意要点：

- 不允许重复声明
- 未定义使用会报错：`const`和`let`不存在变量提升
- 暂时性死区：在代码块内使用`const`和`let`**声明变量前**，该变量都不可用

### 1.1.数据类型

- 8种内置类型。
  - 分为基本类型和引用类型。
    - 7个基本类型
      - `Number、String、Boolean、Undefined、Null、Symbol、BigInt`
    - 引用类型 Object
      - `Array、Function 、Date、RegExp`**等**

#### 1.1.1`typeof `

>  `typeof`返回结果:`number，string，undefined，object，boolean，function，symbol,bigint`

- `typeof null`==="object" 
  - null值表示一个空对象指针,可以利用`Object.prototype.toString.call(null)`来进行正确的判断
- `typeof`  [ ] === "object"

#### 1.1.2`instanceof`

> 用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性。
>
> 用于判断一个变量是否某个对象的实例。

- 实例.`__proto__ `=== 原型链上任意的构造函数（原型对象）.prototype
- 实例.`__proto__.constructor` === 实例的构造函数

## 2  变量的解构赋值

> `ES6` 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（`Destructuring`）

- **解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。**
- `undefined`和`null`无法转为对象，对它们进行解构赋值，会报错。

### 2.1 数组的结构赋值

```javascript
let [a, b, c] = [1, 2, 3]
let [ , , third] = ["foo", "bar", "baz"];
let [head, ...tail] = [1, 2, 3, 4];
let [x, y, ...z] = ['a'];// foo为undefined,z为[]
let [foo = true] = [];//默认值
```

- 解构不成功（值为undefined）。
- 不完全解构（只匹配部分的值）。
- 解构目标不是可遍历对象（Iterator），将报错。
- 解构赋值允许指定默认值。
  - ===undefined，才会启用默认值，null也不行。
  - 默认值是表达式（包括函数），则是惰性求值（用到时才会求值）。
  - 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
- 可用于嵌套结构

### 2.2 对象的解构赋值

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
const { log } = console;
log('hello')
```

- 变量必须与属性同名，才能取到正确的值。

  - 可用新的变量名去取值

    ```javascript
    let obj = { first: 'hello', last: 'world' };
    let { first: f, last: l } = obj;//变量名与属性名不一致
    ```

- 可将现有对象的方法，赋值到某个变量。

- 实际上是对象扩展中的属性简写。

- 可用于嵌套结构。

- 若解构模式是嵌套的对象，而子对象所在的父属性不存在，将会报错。

  ```javascript
  let {foo: {bar}} = {baz: 'baz'}; // 报错
  ```

- 对象的解构赋值可以取到继承的属性。

- 可指定默认值。

  - ===undefined，才会启用默认值，null也不行。

注意要点：

- 用已声明的变量去解构，需要放到一个括号里面。

  ``` javascript
  let x;
  //{x} = {x: 1};//JavaScript 引擎会将{x}理解成一个代码块，所以语法错误
  ({x} = {x: 1});//正确
  ```

- 允许等号左边的模式之中，不放置任何变量名。

  ```javascript
  ({} = [true, false]);
  ({} = 'abc');
  ({} = []);
  ```

- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

  ```javascript
  let arr = [1, 2, 3];
  let {0 : first, [arr.length - 1] : last} = arr;
  ```

### 2.3 字符串的解构赋值

https://es6.ruanyifeng.com/#docs/destructuring

- 字符串也可以解构赋值。

  - 此时，字符串被转换成了一个类似数组的对象。

  ```javascript
  const [a, b, c, d, e] = 'hello';
  let {length : len} = 'hello';
  ```

### 2.4 数值和布尔值的解构赋值

- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

  ```javascript
  let {toString: s} = 123;
  s === Number.prototype.toString // true
  let {toString: s} = true;
  s === Boolean.prototype.toString // true
  ```

### 2.5 函数参数的解构赋值

- 函数的参数也可以使用解构赋值。
- 函数参数的解构也可以使用默认值。

### 2.6 圆括号问题

- 只要有可能导致解构的歧义，就不得使用圆括号。

**不能使用圆括号的情况：**

1. 变量声明语句。
2. 函数参数。
3. 赋值语句。

```javascript
let [(a)] = [1];//报错
function f([(z)]) { return z; }// 报错
({ p: a }) = { p: 42 };//报错
```

**可以使用圆括号的情况：**

1. 赋值语句的非模式部分。

   ```javascript
   [(b)] = [3]; // 正确
   ({ p: (d) } = {}); // 正确
   [(parseInt.prop)] = [3]; // 正确
   ```

   都是赋值语句，且圆括号都不属于模式的一部分。

### 2.7 用途

1. 交互变量的值。

   ```javascript
    [x, y] = [y, x];
   ```

2. 从函数返回多个值。

   ```javascript
   // 返回一个数组
   function example() {return [1, 2, 3];}
   let [a, b, c] = example();
   // 返回一个对象
   function example() { return { foo: 1,bar: 2};}
   let { foo, bar } = example();
   ```

3. 函数参数的定义。

   ```javascript
   // 参数是一组有次序的值
   function f([x, y, z]) { ... }
   f([1, 2, 3]);
   // 参数是一组无次序的值
   function f({x, y, z}) { ... }
   f({z: 3, y: 2, x: 1});
   ```

4. 提取`JSON`数据。

5. 函数参数默认值。

6. 遍历Map解构。

   ```javascript
   for (let [key, value] of map) {
     console.log(key + " is " + value);
   }
   ```

7. 输入模块的指定方法。

   ```javascript
   const { SourceMapConsumer, SourceNode } = require("source-map");
   ```

## 3 字符串

### 3.1 扩展

3.1.1 字符对Unicode表示法

- 允许采用`\uxxxx`的形式表示一个字符，其中`xxxx`表示字符的Unicode码点

- 超出`\u0000`~`\uFFFF`之间的字符，可将码点放在大括号内，就能正确解读该字符。

  - 解决了用两个双字节的形式表示时单个字符不能显示的问题
  - 解决了超过`0xFFFF`的数值（比如`\u20BB7`），JavaScript 会理解成`\u20BB+7`的问题。

- 至此，JavaScript 共有 6 种方法可以表示一个字符。

  ```javascript
  '\z' === 'z'  // true
  '\172' === 'z' // true
  '\x7A' === 'z' // true
  '\u007A' === 'z' // true
  '\u{7A}' === 'z' // true
  ```



3.1.2 字符串新增遍历器接口（`Interator`），使得可被for...of遍历循环。

- 遍历器可识别大于`0xFFFF`的码点（传统的for循环不能）。

3.1.3 模板字符串

1. 用反引号表示。

2. 在模板字符串中需要使用反引号，则前面要用反斜杠转义。
3.  表示多行字符串，所有的空格和缩进都会被保留在输出之中。

4. 嵌入变量，需要将变量名写在`${}`之中。

   - 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。
   - 模板字符串之中还能调用函数。
   - 能嵌套模板字符串。

5. 标签模板

   - 紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。

     ```javascript
     alert`hello`
     // 等同于
     alert(['hello'])
     ```

   - 模板字符里面有变量，会将模板字符串先处理成多个参数，再调用函数。

     ```javascript
     let a = 5;
     let b = 10;
     
     tag`Hello ${ a + b } world ${ a * b }`;
     // 等同于
     tag(['Hello ', ' world ', ''], 15, 50);
     ```

   - 模板处理函数的第一个参数（模板字符串数组），还有一个`raw`属性。

     ```javascript
     console.log`123`
     // ["123", raw: Array[1]]
     ```

     

6. 限制 

   - 模板字符串默认会将字符串转义

### 3.2 新增方法



## 4 正则的扩展

## 5 数值的扩展

## 6 函数的扩展

## 7 数组的扩展

## 8 对象的扩展

## 9 运算符的扩展

## 10 Symbol

## 11 Set

## 12 Map

## 13 Proxy

## 14 Reflect

## 15 Promise

## 16 `Interator`和for...of

## 17 Generator

## 18 Class

## 19 Module

## 20 `ArrayBuffer`