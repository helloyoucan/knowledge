

### 状态管理

##### StatelessWidget

不需要状态更改的widhet，没有要管理的的内部状态。

> 用户界面不需要依赖对象本身中的配置信息以及Widget的BuildContext

无状态的widget的build方法通常之后在以下三种情况调用：

- 将widget插入树中
- 当widget的父级更改其配置时
- 当它依赖的inherritedWidget发生变化时



##### StatefulWidget

- 使用setState方法管理StatefulWidget的状态的改变

```dart
class A extends StatefulWidget{
    _AState createState() => _ASTate();
}
class _AState extends State<A>{
    int index= 0;
    void initState(){
        index = 1;
    }
    /*
    * setState((){
    *	index=3;
    * });
    */
    Widget build(BuildContext context){
        
    }
}
```





### 路由与导航

###### 管理多屏幕：Route和Navigator

- Route是应用程序的“屏幕”或“页面”的抽象（可以认为是Activity）
- Navigatior是管理Route的Widget，Navigatior可以用过push和pop route实现页面切换

###### 以上两种widget对应Flutter中实现页面的有两种选择：

- 具体指定一个路由名构成的Map。(MaterialApp)
- 直接跳转到一个路由。（WidgetApp）

```dart
void main(){
    runApp(MaterialApp(
	    home:MyAppHome(), // becomes the route named '/'
        routes:<string,Widget>{
            '/a':(BuilderContext context) => MyPage(title:'Page A'),
            '/b':(BuilderContext context) => MyPage(title:'Page B'),
            '/c':(BuilderContext context) => MyPage(title:'Page C'),
        }
    ));
}
```



###### 通过把路由名字push给一个Navigatior来跳转：

```dart
Navigatior.of(context).pushName('/b');
```

###### 使用Navigatior的push方法，将给定route添加到导航器的历史记录中。

```dart
Navigatior.push(context,MaterialPageRoute(builder:(BuilderContext context)=>UsualNavscreen())); // MaterialPageRoute为模板路由，它根据平台自适应替换整个页面
```

###### 获取路由跳转返回的结果

Navigatior类不仅用来处理Flutter中的路由，还被用来获取刚push到栈中的路由返回的结果，通过await等待路由返回的结果，来达到获取跳转页面后返回的结果。

e.g. 跳转到“位置”路由来让用户选择一个地点：

```
Map coordinates = await Navigatior.of(context).pushName('/location');
```

之后，在location路由中，一旦用户选择了地点，携带结果一起pop（）出栈：