## 1  声明

- `const` 声明常量，需声明时赋值（仅在块级作用域内有效）
- `let` 声明变量，可声明时或使用时赋值（仅在块级作用域内有效）
- `var` 声明变量，具有变量提升（可**声明前**使用）
- `function` 声明函数，具有函数提升（可**声明赋值前**使用）

**6个**用于声明的关键字

`var、const、let、function、class、import`

作用域：

- 全局作用域
- 函数作用域：function(){}
- 块级作用域：{}

`const`和`let`注意要点：

- 不允许重复声明
- 未定义使用会报错：`const`和`let`不存在变量提升
- 暂时性死区：在代码块内使用`const`和`let`**声明变量前**，该变量都不可用

### 1.1.数据类型

- 8种内置类型。
  - 分为基本类型和引用类型。
    - 7个基本类型
      - `Number、String、Boolean、Undefined、Null、Symbol、BigInt`
    - 引用类型 Object
      - `Array、Function 、Date、RegExp`**等**

#### 1.1.1`typeof `

>  `typeof`返回结果:`number，string，undefined，object，boolean，function，symbol,bigint`

- `typeof null`==="object" 
  - null值表示一个空对象指针,可以利用`Object.prototype.toString.call(null)`来进行正确的判断
- `typeof`  [ ] === "object"

#### 1.1.2`instanceof`

> 用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性。
>
> 用于判断一个变量是否某个对象的实例。

- 实例.`__proto__ `=== 原型链上任意的构造函数（原型对象）.prototype
- 实例.`__proto__.constructor` === 实例的构造函数

## 2  变量的解构赋值

> `ES6` 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（`Destructuring`）

- **解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。**
- `undefined`和`null`无法转为对象，对它们进行解构赋值，会报错。

### 2.1 数组的结构赋值

```javascript
let [a, b, c] = [1, 2, 3]
let [ , , third] = ["foo", "bar", "baz"];
let [head, ...tail] = [1, 2, 3, 4];
let [x, y, ...z] = ['a'];// foo为undefined,z为[]
let [foo = true] = [];//默认值
```

- 解构不成功（值为undefined）。
- 不完全解构（只匹配部分的值）。
- 解构目标不是可遍历对象（Iterator），将报错。
- 解构赋值允许指定默认值。
  - ===undefined，才会启用默认值，null也不行。
  - 默认值是表达式（包括函数），则是惰性求值（用到时才会求值）。
  - 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
- 可用于嵌套结构

### 2.2 对象的解构赋值

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
const { log } = console;
log('hello')
```

- 变量必须与属性同名，才能取到正确的值。

  - 可用新的变量名去取值

    ```javascript
    let obj = { first: 'hello', last: 'world' };
    let { first: f, last: l } = obj;//变量名与属性名不一致
    ```

- 可将现有对象的方法，赋值到某个变量。

- 实际上是对象扩展中的属性简写。

- 可用于嵌套结构。

- 若解构模式是嵌套的对象，而子对象所在的父属性不存在，将会报错。

  ```javascript
  let {foo: {bar}} = {baz: 'baz'}; // 报错
  ```

- 对象的解构赋值可以取到继承的属性。

- 可指定默认值。

  - ===undefined，才会启用默认值，null也不行。

注意要点：

- 用已声明的变量去解构，需要放到一个括号里面。

  ``` javascript
  let x;
  //{x} = {x: 1};//JavaScript 引擎会将{x}理解成一个代码块，所以语法错误
  ({x} = {x: 1});//正确
  ```

- 允许等号左边的模式之中，不放置任何变量名。

  ```javascript
  ({} = [true, false]);
  ({} = 'abc');
  ({} = []);
  ```

- 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

  ```javascript
  let arr = [1, 2, 3];
  let {0 : first, [arr.length - 1] : last} = arr;
  ```

### 2.3 字符串的解构赋值

https://es6.ruanyifeng.com/#docs/destructuring

- 字符串也可以解构赋值。

  - 此时，字符串被转换成了一个类似数组的对象。

  ```javascript
  const [a, b, c, d, e] = 'hello';
  let {length : len} = 'hello';
  ```

### 2.4 数值和布尔值的解构赋值

- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

  ```javascript
  let {toString: s} = 123;
  s === Number.prototype.toString // true
  let {toString: s} = true;
  s === Boolean.prototype.toString // true
  ```

### 2.5 函数参数的解构赋值

- 函数的参数也可以使用解构赋值。
- 函数参数的解构也可以使用默认值。

### 2.6 圆括号问题

- 只要有可能导致解构的歧义，就不得使用圆括号。

**不能使用圆括号的情况：**

1. 变量声明语句。
2. 函数参数。
3. 赋值语句。

```javascript
let [(a)] = [1];//报错
function f([(z)]) { return z; }// 报错
({ p: a }) = { p: 42 };//报错
```

**可以使用圆括号的情况：**

1. 赋值语句的非模式部分。

   ```javascript
   [(b)] = [3]; // 正确
   ({ p: (d) } = {}); // 正确
   [(parseInt.prop)] = [3]; // 正确
   ```

   都是赋值语句，且圆括号都不属于模式的一部分。

### 2.7 用途

1. 交互变量的值。

   ```javascript
    [x, y] = [y, x];
   ```

2. 从函数返回多个值。

   ```javascript
   // 返回一个数组
   function example() {return [1, 2, 3];}
   let [a, b, c] = example();
   // 返回一个对象
   function example() { return { foo: 1,bar: 2};}
   let { foo, bar } = example();
   ```

3. 函数参数的定义。

   ```javascript
   // 参数是一组有次序的值
   function f([x, y, z]) { ... }
   f([1, 2, 3]);
   // 参数是一组无次序的值
   function f({x, y, z}) { ... }
   f({z: 3, y: 2, x: 1});
   ```

4. 提取`JSON`数据。

5. 函数参数默认值。

6. 遍历Map解构。

   ```javascript
   for (let [key, value] of map) {
     console.log(key + " is " + value);
   }
   ```

7. 输入模块的指定方法。

   ```javascript
   const { SourceMapConsumer, SourceNode } = require("source-map");
   ```

## 3 字符串

### 3.1 扩展

3.1.1 字符对Unicode表示法

- 允许采用`\uxxxx`的形式表示一个字符，其中`xxxx`表示字符的Unicode码点

- 超出`\u0000`~`\uFFFF`之间的字符，可将码点放在大括号内，就能正确解读该字符。

  - 解决了用两个双字节的形式表示时单个字符不能显示的问题
  - 解决了超过`0xFFFF`的数值（比如`\u20BB7`），JavaScript 会理解成`\u20BB+7`的问题。

- 至此，JavaScript 共有 6 种方法可以表示一个字符。

  ```javascript
  '\z' === 'z'  // true
  '\172' === 'z' // true
  '\x7A' === 'z' // true
  '\u007A' === 'z' // true
  '\u{7A}' === 'z' // true
  ```



3.1.2 字符串新增遍历器接口（`Interator`），使得可被for...of遍历循环。

- 遍历器可识别大于`0xFFFF`的码点（传统的for循环不能）。

3.1.3 模板字符串

1. 用反引号表示。

2. 在模板字符串中需要使用反引号，则前面要用反斜杠转义。
3.  表示多行字符串，所有的空格和缩进都会被保留在输出之中。

4. 嵌入变量，需要将变量名写在`${}`之中。

   - 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。
   - 模板字符串之中还能调用函数。
   - 能嵌套模板字符串。

5. 标签模板

   - 紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。

     ```javascript
     alert`hello`
     // 等同于
     alert(['hello'])
     ```

   - 模板字符里面有变量，会将模板字符串先处理成多个参数，再调用函数。

     ```javascript
     let a = 5;
     let b = 10;
     
     tag`Hello ${ a + b } world ${ a * b }`;
     // 等同于
     tag(['Hello ', ' world ', ''], 15, 50);
     ```

   - 模板处理函数的第一个参数（模板字符串数组），还有一个`raw`属性。

     ```javascript
     console.log`123`
     // ["123", raw: Array[1]]
     ```

     

6. 限制 

   - 模板字符串默认会将字符串转义

### 3.2 新增方法

1. `String.formCodePoint()`

   - 可识别码点大于`0xFFFF`的字符
   - 解决`ES5`的`String.fromCharCode()`不能识别大于`0xFFFF`的码点的问题

2. `String.raw()`

   - return 一个斜杠都被转义的字符串（已转义则继续转义）
   - 常用语模板字符串的处理方法
     - 会将所有变量替换
   - 第一个参数，应该是一个具有`raw`属性的对象，且`raw`属性的值应该是一个数组，对应模板字符串解析后的值。

   ```javascript
   String.raw`Hi\\n` // 返回 "Hi\\\\n"
   // ----------------------------------------
   // `foo${1 + 2}bar`
   // 等同于
   String.raw({ raw: ['foo', 'bar'] }, 1 + 2) // "foo3bar"
   ```

3. `codePointAt()`

   JavaScript 内部，字符以` UTF-16 `的格式储存，每个字符固定为`2`个字节。对于那些需要`4`个字节储存的字符（Unicode 码点大于`0xFFFF`的字符），JavaScript 会认为它们是两个字符。

   ```javascript
   var s = "𠮷";
   s.length // 2
   s.charAt(0) // ''
   s.charAt(1) // ''
   s.charCodeAt(0) // 55362
   s.charCodeAt(1) // 57271
   s.codePointAt(0).toString(16) // "20bb7" //转16进制
   s.codePointAt(2).toString(16) // "61" //转16进制
   ```

   - 够正确处理 4 个字节储存的字符，返回一个字符的码点（十进制值），想要十六进制的值，可以使用`toString()`方法转换一下（**`Number.prototype.toString`可传参转换为指定进制的数值字符串**）。

   - 解决`charAt()`方法无法读取整个字符的问题

   - 解决`charCodeAt()`方法只能分别返回前两个字节和后两个字节的值的问题。

   - `codePointAt()`方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。

     ```javascript
     function is32Bit(c) { return c.codePointAt(0) > 0xFFFF;}
     is32Bit("𠮷") // true
     is32Bit("a") // false
     ```

   注意：

   - `odePointAt()`方法的参数，仍然是不正确的。(下面的最好一行代码，`codePointAt`的参数为2才能拿到正确的字符串码点)

     ```javascript
     let s = '𠮷a';
     s.codePointAt(0).toString(16) // "20bb7"
     s.codePointAt(2).toString(16) // "61"
     ```

     解决方法：

     - 使用`for...of`循环，因为它会正确识别 32 位的 `UTF-16` 字符。
     - 使用扩展运算符（`...`）进行展开运算。

4. `normalize()`

   许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如`Ǒ`（`\u01D1`）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如`O`（`\u004F`）和`ˇ`（`\u030C`）合成`Ǒ`（`\u004F\u030C`）。

   - 将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。

     ```javascript
     '\u01D1'==='\u004F\u030C' //false
     '\u01D1'.normalize() === '\u004F\u030C'.normalize() // true
     ```

   注意：

   - `normalize`方法不能识别中文。
   - 不能识别三个或三个以上字符的合成。（只能使用正则表达式，通过 Unicode 编号区间判断。）

5. `includes()` #返回布尔值，表示是否找到了参数字符串。

6. `startsWith()` #返回布尔值，表示参数字符串是否在原字符串的头部。

7. `endsWith()` #返回布尔值，表示参数字符串是否在原字符串的尾部。

8. `repeat()` 

   - 返回一个新字符串，表示将原字符串重复`n`次。
   - 参数是 0 到-1 之间的小数，则等同于 0。（会先进行取整运算）
   - 0 到-1 之间的小数，取整以后等于`-0`，`repeat`视同为 0。
   - 参数`NaN`等同于 0。
   - 参数是字符串，则会先转换成数字。

9. `padStart(),padEnd()`

   - 如果某个字符串不够指定长度，会在头部或尾部补全。
   - 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。
   - 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。
   - 省略第二个参数，默认使用空格补全长度。
   
10. `trimStart(),trimEnd()`

   - 与`trim()`一致。
   - `trimStart()`消除字符串头部空格。
   - `trimEnd()`消除字符串尾部空格。
   - 都是新字符串，不会修改原始字符串。
   - 对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。
   - 浏览器还部署了额外的两个方法，`trimLeft()`是`trimStart()`的别名，`trimRight()`是`trimEnd()`的别名。

## 4 正则的扩展

## 5 数值的扩展

## 6 函数的扩展

## 7 数组的扩展

## 8 对象的扩展

## 9 运算符的扩展

## 10 Symbol

## 11 Set

## 12 Map

## 13 Proxy

## 14 Reflect

## 15 Promise

## 16 `Interator`和for...of

## 17 Generator

## 18 Class

## 19 Module

## 20 `ArrayBuffer`