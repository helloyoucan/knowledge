##### 新概念 createApp （解决vue2多个实例共享全局配置）

```javascript
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App)
app.mount('#app')
```

#### 全局api

| vue 2.x                    | vue 3.x                    |
| -------------------------- | -------------------------- |
| Vue.config                 | app.config                 |
| Vue.config.productionTip   | 移除                       |
| Vue.config.ignoredElements | app.config.isCustomElement |
| Vue.component              | app.component              |
| Vue.directive              | app.directive              |
| Vue.mixin                  | app.mixin                  |
| Vue.use                    | app.use                    |
| Vue.observable             | Vue.reactive               |
|                            |                            |



#### nextTick

```javascript
Vue.nextTick(() => {})
this.$nextTick(() => {})

//新语法

import { nextTick } from 'vue'
nextTick(() => {
  // something DOM-related
})
```



#### 移除inline-template

```vue
<my-component inline-template>
  <div>
    <p>These are compiled as the component's own template.</p>
    <p>Not parent's transclusion content.</p>
  </div>
</my-component>
```

- 使用script标签代替

  ```html
  <script type="text/html" id="my-comp-template">
    <div>{{ hello }}</div>
  </script>
  ```

- 使用默认插槽（区分数据作用域）

  ```html
  <template>
    <slot :childState="childState" />
  </template>
  ```

  

#### key 属性

- `v-if`/ `v-else`/`v-else-if`不再需要手动添加

- `<template v-for>` 上也可使用key

  ```html
  <!-- Vue 2.x -->
  <template v-for="item in list">
    <div v-if="item.isVisible" :key="item.id">...</div>
    <span v-else :key="item.id">...</span>
  </template>
  
  <!-- Vue 3.x -->
  <template v-for="item in list" :key="item.id">
    <div v-if="item.isVisible">...</div>
    <span v-else>...</span>
  </template>
  ```

#### KeyCode修饰符

- v-on不再支持使用数字（<input v-on:keyup.13="submit" />）
- 移除Vue.config.keyCodes 

3.x语法：

- 标准修饰符：[`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)

```html
<input v-on:keyup.delete="confirmDelete" />
```

```html
<input @keyup.page-down="onPageDown" /> 仅当$event.key等于时才调用处理程序'PageDown'
```



#### props的default工厂函数不能访问this

3.x的处理：

- 组件接收到的props作为参数传递给默认函数;
- 该inject API可以在里面默认的功能一起使用。

```javascript
import { inject } from 'vue'
export default {
  props: {
    theme: {
      default (props) {
        return inject('theme', 'default-theme')
      }
    }
  }
}
```



#### Render Function API

- createElement改为全局导入

  ```javascript
  // Vue 2 Render Function Example
  export default {
    render(h) {
      return h('div')
    }
  }
  
  // Vue 3 Render Function Example
  import { h } from 'vue'
  export default {
    render() {
      return h('div')
    }
  }
  ```

- Render Function Signature Change

- VNode Props Format

- Registered Component

- 

#### Slots

- 公开`this.$slot` 的属性
- 移除`this.$scopedSlots`

引用插槽作用域：

```javascript
// 2.x Syntax
this.$scopedSlots.header

// 3.x Syntax
this.$slots.header()
```



#### Transition Class 的修改

- 在`v-enter`过渡类已重命名为`v-enter-from`和`v-leave`过渡类已更名为`v-leave-from`



#### v-model

- 自定义组件上使用v-model的prop和event的默认名称已变
  - prop:  value 变为modelValue
  - event: input 变为 update:modelValue
  - 移除v-bind的.sync修饰符和组件的model选项，使用v-model的参数实现原有功能
  - v-model可以在同一组件绑定多个属性
  - 新增创建自定义v-model修饰符的功能

3.x

```javascript
// v-model默认的修饰符为modelValue
<ChildComponent v-model="pageTitle" /> // 等价于v-model:modelValue="pageTitle"
// ChildComponent.vue

export default {
  props: {
    modelValue: String // previously was `value: String`
  },
  methods: {
    changePageTitle(title) {
      this.$emit('update:modelValue', title) // previously was `this.$emit('input', title)`
    }
  }
}
```



```html
<ChildComponent v-model:title="pageTitle" />
<!-- 等价于 -->
<ChildComponent :title="pageTitle" @update:title="pageTitle = $event" />
```





#### v-if和v-for优先

- 3.x中，v-if的优先级始终高于v-for



#### v-bind合并行为

- v-bind的绑定书匈奴将影响渲染结果

2.x

```html
<!-- template -->
<div id="red" v-bind="{ id: 'blue' }"></div>
<!-- result -->
<div id="red"></div>
```

3.x

```html
<!-- template -->
<div id="red" v-bind="{ id: 'blue' }"></div>
<!-- result -->
<div id="blue"></div>

<!-- template -->
<div v-bind="{ id: 'blue' }" id="red"></div>
<!-- result -->
<div id="red"></div>
```



#### ref

3.x中，绑定多个ref不再自动创建数组，可以给ref绑定一个方法，手动创建数组或对象管理ref

```html
<div v-for="item in list" :ref="setItemRef"></div>
```

```javascript
//使用Options API：
export default {
  data() {
    return {
      itemRefs: []
    }
  },
  methods: {
    setItemRef(el) {
      this.itemRefs.push(el)
    }
  },
  beforeUpdate() {
    this.itemRefs = []
  },
  updated() {
    console.log(this.itemRefs)
  }
}
```

或

```javascript
//使用Composition API：
import { ref, onBeforeUpdate, onUpdated } from 'vue'
export default {
  setup() {
    let itemRefs = []
    const setItemRef = el => {
      itemRefs.push(el)
    }
    onBeforeUpdate(() => {
      itemRefs = []
    })
    onUpdated(() => {
      console.log(itemRefs)
    })
    return {
      itemRefs,
      setItemRef
    }
  }
}
```

注意：

- `itemRefs` 不必是数组：它也可以是通过引用的迭代键设置引用的对象。
- `itemRefs`如果需要的话，这也可以使之反应并观察。



#### teleport 

- 在指定地方渲染模板

```javascript
app.component('modal-button', {
  template: `
    <button @click="modalOpen = true">
        Open full screen modal! (With teleport!)
    </button>

    <teleport to="body">
      <div v-if="modalOpen" class="modal">
        <div>
          I'm a teleported modal! 
          (My parent is "body")
          <button @click="modalOpen = false">
            Close
          </button>
        </div>
      </div>
    </teleport>
  `,
  data() {
    return { 
      modalOpen: false
    }
  }
})
```

####  Fragments

- 支持多个子元素

```html
2.x
<!-- Layout.vue -->
<template>
  <div>
    <header>...</header>
    <main>...</main>
    <footer>...</footer>
  </div>
</template>

3.x
<!-- Layout.vue -->
<template>
  <header>...</header>
  <main v-bind="$attrs">...</main>
  <footer>...</footer>
</template>
```



#### 组件的自定义事件

- 事件名称：不提供大小写转换，建议对事件名称使用kebab-case（短横线命名）

- 使用emits声明在组件上发出的事件

  ```javascript
  export default{
  	 emits: ['in-focus', 'submit'，'click']
  }
  // 在emits定义了click事件，会覆盖原生事件
  ```

- 验证组件内emit的事件

  ```javascript
  app.component('custom-form', {
    emits: {
      // No validation
      click: null,
      // Validate submit event
      submit: ({ email, password }) => {
        if (email && password) {
          return true
        } else {
          console.warn('Invalid submit event payload!')
          return false
        }
      }
    },
    methods: {
      submitForm() {
        this.$emit('submit', { email, password })
      }
    }
  })
  ```


#### 新功能（语法）
##### SFC Composition API Syntax Sugar (<script setup>)
```vue
<template>
  <button @click="inc">{{ count }}</button>
</template>
新语法
<script setup>
  import { ref } from 'vue'
  export const count = ref(0)
  export const inc = () => count.value++
</script>
 
对应的旧语法
<script >
export default {
  setup() {
    const count = ref(0)
    const inc = () => count.value++

    return {
      count,
      inc,
    }
  },
}
</script>
```



##### 支持将组件状态驱动的CSS变量注入到“单个文件组件”样式中。

```vue
<template>
  <div class="text">hello</div>
</template>

<script>
export default {
  data() {
    return {
      color: 'red'
    }
  }
}
</script>

<style vars="{ color }">
.text {
  color: var(--color);
}
</style>
```

##### 以“单个文件组件”作用域样式提供更一致的自定义CSS扩展。

- 移除">>>"和“/deep/”css深度选择的语法’

- 新增"::v-deep"（简写":deep"）

  ```vue
  <style scoped>
  /* deep selectors(深度选择器) */
  ::v-deep(.foo) {}
  /* shorthand (简写)*/
  :deep(.foo) {}
  
  /* targeting slot content(针对槽内容) */
  ::v-slotted(.foo) {}
  /* shorthand(简写) */
  :slotted(.foo) {}
  
  /* one-off global rule(一次性全局规则) */
  ::v-global(.foo) {}
  /* shorthand(简写) */
  :global(.foo) {}
  </style>
  ```

  